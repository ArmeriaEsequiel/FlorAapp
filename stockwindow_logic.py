# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'stockwindow2.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.



#        self.StockWindow = StockWindow

from functools import partial
import xlwt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from db_handler import *
from stockwindow import Ui_StockWindow

class StockWindow(QtWidgets.QMainWindow, Ui_StockWindow):
    def __init__(self, *args, obj=None, **kwargs):
        super(StockWindow, self).__init__(*args, **kwargs)
        self.setupUi(self)
        self.row_count = 0
        self.checked_list = []
        self.store_list = []
        self.front_list = []
        self.last_checked = []
        self.is_checked = True
        self.method = 0 #Method to select flow in one_to_front
#        self.store_list = []

        # Activation close_stock_window
        self.close_stock_window.clicked.connect(self.close_stock_window_clicked)

        #Activation for searchbutton. Search products.
        self.searchbutton.clicked.connect(self.searchbutton_clicked)

        #Activation for increase_stock and decrease_stock
        self.increase_stock.clicked.connect(self.increase_stock_clicked)
        self.Decrease_stock.clicked.connect(self.decrease_stock_clicked)

        #Activation for move stocke from store to storage, and viceversa
        self.one_to_storage.clicked.connect(partial(self.one_to_storage_clicked,self.method))
        self.one_to_front.clicked.connect(partial(self.one_to_storage_clicked,self.method+1))

        #Activation
        self.storage_missing.clicked.connect(partial(self.out_of_stock,self.method))
        self.front_missing.clicked.connect(partial(self.out_of_stock,self.method+1))

        #Activation for dumping stock to a excel file
        self.dump_stock.clicked.connect(self.dump_stock_clicked)



    #Clean lists for next search
    def clean_lists(self):
        self.checked_list = []
        self.store_list = []
        self.front_list = []

    #Method 0 = to storage
    #Method 1 = to front
    def ischecked(self):
        method = 1
        if(self.checkBox.isChecked() or self.checkBox_2.isChecked()):
#            print("-------------------------------------------------------------------------")
#            print("lista elegida {}".format(self.front_list))
            list_selected = self.front_list
            method = 0
        else:
#            print("lista elegida {}".format(self.store_list))
            list_selected = self.store_list
        return(method,list_selected)


    def select_list_and_Qspin_value(self,method):
        if method == 0:
            selected_to_check = self.front_list
            selected_to_iterate = self.store_list
            value = self.n_to_storage_num.value()
        else:
            selected_to_check = self.store_list
            selected_to_iterate = self.front_list
            value = self.n_to_front_num.value()
        return(selected_to_iterate,selected_to_check,value)


    def table_fillup_with_search(self):
        if self.row_count == 0:
            return(0)
        self.tableWidget.clearContents()
        product = get_products_from_list(self.last_checked)
        self.row_count = 0
        self.tableWidget.setRowCount(0)
        for row_number, row_data, in enumerate(product):
            self.tableWidget.insertRow(row_number)
            for column_number, data in enumerate(row_data):
                if type(data) == float:
                    data = int(data)
                item = QTableWidgetItem(str(data))
                item.setTextAlignment(Qt.AlignCenter)
                font = QtGui.QFont()
                font.setPointSize(18)
                item.setFont(font)
                self.tableWidget.setItem(row_number,column_number,item)
            #Create CheckBox 
            check_box_item = QTableWidgetItem()
            check_box_item.setCheckState(Qt.Unchecked)
            check_box_item.setText("Seleccionar")
            self.tableWidget.setItem(row_number,4,check_box_item)
            self.row_count = self.row_count + 1


#---------------------------------------------------------------------
    

    def out_of_stock(self,method):
        self.tableWidget.clearContents()
        self.row_count = 0
        if(method == False):
            product = get_storage_out_of_stock()
        else:
            product = get_shop_out_of_stock()
#        print("CANTIDAD PRODUCTOS {}".format(enumerate(product)))
        self.tableWidget.setRowCount(0)
        for row_number, row_data, in enumerate(product):
#            print("ENTRE")
            self.row_count = self.row_count + 1 
            self.tableWidget.insertRow(row_number)
            for column_number, data in enumerate(row_data):
                if type(data) == float:
                    data = int(data)
                item = QTableWidgetItem(str(data))
                print("EL ITEM ES {}".format(item.text()))
                item.setTextAlignment(Qt.AlignCenter)
                font = QtGui.QFont()
                font.setPointSize(18)
                item.setFont(font)
                self.tableWidget.setItem(row_number,column_number,item)
            #Create CheckBox 
            check_box_item = QTableWidgetItem()
            check_box_item.setCheckState(Qt.Unchecked)
            check_box_item.setText("Seleccionar")
            self.tableWidget.setItem(row_number,4,check_box_item)
#        print("ROW COUNT {}".format(self.row_count))
#        print("----------------------------------------------------")





    #Close window
    def close_stock_window_clicked(self):
        self.StockWindow.close()


    #Send product from shop to storage
    def one_to_storage_clicked(self,method_for_modify_stock):
        i = 0
        method_for_store = 1
        method_for_shop = 0
        #Not letting other buttons make searchs when pressed
        self.get_checked_products()
        if self.row_count == 0 or self.checked_list == []:
            return(0)
        #value = self.n_to_storage_num.value()
 #       print("CHECKED ES {}".format(self.checked_list))
        iterate_list, check_list, value = self.select_list_and_Qspin_value(method_for_modify_stock)
 #       print("iterate list is {}".format(iterate_list))
 #       print("check list is {}".format(check_list)) 
 #       print("Value es {}".format(value))
        for item in iterate_list:
            #Si no hay stock en el negocio no se puede subir al deposito.
            if check_list[i] != 0:
                update_stored = value + item 
                update_shop = check_list[i] - value
                #Si cantidad sacar > cantidad existente, se pasa cantidad existente. 
                if update_shop < 0:
                    update_shop = 0
                    update_stored = check_list[i] + item
                if method_for_modify_stock == 0:
                    change_stock(str(update_stored),self.checked_list[i],method_for_store)
                    change_stock(str(update_shop),self.checked_list[i],method_for_shop)
                else:
                    change_stock(str(update_stored),self.checked_list[i],method_for_shop)
                    change_stock(str(update_shop),self.checked_list[i],method_for_store)

            i = i+1
        #self.searchbutton_clicked()
        self.table_fillup_with_search()
        self.clean_lists()

    #Increase stock, depending on QSpingBox.
    def increase_stock_clicked(self):
        self.get_checked_products()
        if self.row_count == 0 or self.checked_list == []:
            return(0)
        method, list_selected = self.ischecked()
        if list_selected == []:
            return(0)
        i = 0
        value = self.n_increase_stock.value()
        for item in list_selected:
            update = value + item
            change_stock(update,self.checked_list[i],method)
            i = i+1

        #Clean lists for next search and modification.
        #self.searchbutton_clicked(self.is_checked)
#        print("row_count es {}".format(self.row_count))
        #self.searchbutton_clicked()
        self.table_fillup_with_search()    
        self.clean_lists()

    # Decreasing stock depending on QSpinBox
    def decrease_stock_clicked(self):
        self.get_checked_products()
        if self.row_count == 0 or self.checked_list == []:
            return(0)
        method, list_selected = self.ischecked()
        if list_selected == []:
            return(0)
        i = 0
        value = self.n_decrease_stock.value()
        for item in list_selected:
            update = int(item) - value
            if update < 0:
                update = 0
            change_stock(update,self.checked_list[i],method)
            i = i+1

        #Clean lists for next search and modification.
#        self.searchbutton_clicked(self.is_checked)
        #self.searchbutton_clicked()
        self.table_fillup_with_search()
        self.clean_lists()


    #Store checked products.
    def get_checked_products(self):
        if self.row_count == 0:
           return(0)
        else:
#            self.row_count =  0
#            print("EN CHECKED ES {}".format(self.tableWidget.item(0,0).text()))
#            print("EN CHECKED ES {}".format(self.tableWidget.item(0,1).text()))
#            print("EN CHECKED ES {}".format(self.tableWidget.item(0,2).text()))
#            print("EN CHECKED ES {}".format(self.tableWidget.item(0,3).text()))
#           print("EN CHECKED ES {}".format(type(self.tableWidget.item(0,4))))
#            print("ROW COUNT ES {}".format(self.row_count))
            for i in range(self.row_count):
                if self.tableWidget.item(i,4).checkState() == Qt.Checked:
                    self.checked_list.append(self.tableWidget.item(i,3).text())
                    self.store_list.append(int(self.tableWidget.item(i,2).text()))
                    self.front_list.append(int(self.tableWidget.item(i,1).text()))
            self.last_checked = self.checked_list




    # Populate table with the product given.
    def searchbutton_clicked(self):#,input_bool):
        self.tableWidget.clearContents()
        self.checked_list = []
        self.row_count = 0
        product = show_product(self.lineEdit.text(),1)
        self.tableWidget.setRowCount(0)
        for row_number, row_data, in enumerate(product):
            self.row_count = self.row_count + 1 
            self.tableWidget.insertRow(row_number)
            for column_number, data in enumerate(row_data):
                if type(data) == float:
                    data = int(data)
                item = QTableWidgetItem(str(data))
                item.setTextAlignment(Qt.AlignCenter)
                font = QtGui.QFont()
                font.setPointSize(18)
                item.setFont(font)
                self.tableWidget.setItem(row_number,column_number,item)
            #Create CheckBox 
            check_box_item = QTableWidgetItem()
            check_box_item.setCheckState(Qt.Unchecked)
            check_box_item.setText("Seleccionar")
            self.tableWidget.setItem(row_number,4,check_box_item)



    def dump_stock_clicked(self):
        FolderName = QtWidgets.QFileDialog.getExistingDirectory(self.StockWindow)
        FileName = FolderName + '/stock.xls'
        if FolderName:
            workbook = xlwt.Workbook()
            sheet = workbook.add_sheet("Stock")

            #ADD HEADERS
            sheet.write(0,0, 'Nombre')
            sheet.write(0,1, 'Precio')
            sheet.write(0,2, 'Codigo de Barras')
            product = show_product("",0)
            for row_number, row_data, in enumerate(product):
                for column_number, data in enumerate(row_data):
                    sheet.write(row_number+1,column_number,str(data))
            workbook.save(FileName)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    StockWindow = StockWindow()
    StockWindow.show()
    sys.exit(app.exec_())